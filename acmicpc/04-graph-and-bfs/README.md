# 그래프와 BFS

## 그래프

- 최단경로: 그래프의 경로 중에서 가장 짧은 것을 의미
- 사이클: 시작점과 도착점이 같은 경로
- 두 정점을 잇는 간선은 여러개일 수 있다.
- 루프: 간선의 양 끝점이 같은 경우를 의미
- 가중치: A에서 B로 이동하는 비용(시간,거리 등...)
- 차수: 정점과 연결되어 있는 간선의 개수
  - in-degree: 들어오는 간선의 수
  - out-degree: 나가는 간선의 수

### 그래프를 어떻게 저장할 것인가?

그래프를 저장하는 것은 정점, 간선 두가지를 저장하는 것을 의미

- 정점은 보통 개수만 저장하면 됨
- 간선은 모두 저장해야함

그래서 보통 간서을 저장하는 것이 그래프를 저장하는 것을 의미하게 됨

#### 인접행렬

```plain
  1 2 3 4
1 0 1 0 0
2 0 0 0 0
3 0 0 0 0
4 0 0 0 0
```

#### 인접리스트

저장되어 있는 순서는 중요하지 않음

- 저장에는 동적인 리스트가 필요 (링크드리스트 or 동적배열 이용)
- X와 연결된 모든 간선을 효율적으로 찾아보고 싶다
  - 인접행렬 : O(v) A[X][1] ~ A[x][v]
  - 인접리스트: O(차수)

```plain
A[1] 2 5
A[2] 1 3 4 5
A[3] 2 4
...
```

대부분의 문제에서 인접리스트를 쓰는것이 유용함. 대부분의 문제가 `E << V^2`이기 때문

#### 간선리스트

```plain
E[0] = 1 2
E[1] = 1 5

------------------------
i      | 0 1 2 3 ...
------------------------
cnt[i] | 0 2 6 8 ...
------------------------
// => 3으로 시작하는 간선은 6번째 부터 8번째 전까지라는 정보를 얻기 좋음
```

## 그래프의 탐색 (DFS, BFS)

목적: 시작전 X에서 시작해, 모든 정점을 한번씩 방문하는 것

- DFS: 스택을 이용해 최대한 많이 탐색
- BFS: 큐를 이용해 탐색

## 플러드 필 (Flood Fill)

어떤 위치와 연결된 모든 위치를 찾는 알고리즘

## BFS

> 2178,

BFS는 최단거리를 구하는 알고리즘 (가중치가 1일 때)

1. 최소 비용 문제이어야 함
2. 간선의 가중치가 1이어야함
3. 정점과 간선의 개수가 적어야함
