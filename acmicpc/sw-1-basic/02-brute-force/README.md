# 브루트 포스

- [브루트 포스](#브루트-포스)
  - [✅ 복습](#-복습)
    - [🔧 문제 해결](#-문제-해결)
    - [🔥 다시 풀어보기](#-다시-풀어보기)
  - [1. 브루트 포스](#1-브루트-포스)
    - [문제풀이](#문제풀이)
    - [공식](#공식)
  - [2. N중 FOR문](#2-n중-for문)
  - [3. 순열](#3-순열)
    - [문제풀이](#문제풀이-1)
  - [4. 재귀 함수 사용하기](#4-재귀-함수-사용하기)
  - [5. 비트마스크](#5-비트마스크)

## ✅ 복습

### 🔧 문제 해결

### 🔥 다시 풀어보기

## 1. 브루트 포스

- 모든 경우의 수를 다 해보는 알고리즘
  - 1. 문제의 가능한 경우의 수를 계산해봄 (가능할까? 판단)
  - 2. 가능한 모든 방법을 다 만들어봄 (하나도 빠짐없이!)
    - for문, 순열, 재귀호출, 비트마스크 등의 방법이 있다.
  - 3. 각각의 방법을 이용해 답을 구한다
- 시간 복잡도
  - 1번 \* 3번 시간 (경우의수 \* 방법1개 시도시간)

### 문제풀이

- 문제에 주어진 변수. 예를 들면 N과 M에 대한 식으로 만드는 것이 중요하다.

### 공식

- nCm = n(n-1) / m = O(N^2)

## 2. N중 FOR문

- N개 중 일부를 선택해야하는 경우에 많이 사용하나,
- 재귀 호출이나 비트마스크를 이용하는 기법이 더 간단하기에 잘 사용하진 않음
- (생각하기 간단하고 좋은 전략이지만 for문이 무척 많으면 실수하기가 쉬움)

## 3. 순열

- 순열은 순서가 중요한 경우 사용!
- 순열의 특징
  - 크기는 N, **겹치는 숫자는 존재하지 않음**
  - 크기가 N인 수열은 총 N!개 존재
- 사전순 순열 만들기
  - 순열을 사전순으로 만들면 첫 순열은 오름차순, 마지막 순열은 내림차순이 된다.
  - 다음 순열을 어떻게 만들까?
    - C++ STL -> `next_permutation`, `prev_permutation`
    - 알고리즘 (O(N))
      - `A[i-1] < A[i]`를 만족하는 가장 큰 `i` 찾기
      - `j >= i` 이면서 `A[j] > A[i-1]` 를 만족하는 가장 큰 `j` 찾기
      - `A[i-1]`과 `A[j]`를 swap
      - `A[i]` 부터 순열을 뒤집기
    - 예시
      - 7236541 -> 723으로 시작하는 마지막 순열
  - 이는 동일한 숫자가 있어도 올바르게 동작함

### 문제풀이

- 모든 순열을 구하려면 N(다음순열) \* N!(모든순서) 이 걸리는데, 그래서 10! 정도면 1억을 넘어버린다. 그래서 문제는 보통 10 제한으로 나올 가능성이 높다.
- 외판원 문제처럼 순환되는 경우, 시작점을 고정해도 결과는 동일
- 숫자또는 값이 정해져있고 그 순서만 바뀌는 경우 순열을 활용할 수 있겠다.

```cpp
// O(N)
bool next_permutation(int *a, int n) {
  int i = n - 1;
  while (i > 0 && a[i-1] >= a[i]) {
    i -= 1;
  }
  if (i <= 0) {
    return false;
  }

  int j = n-1;
  while (a[j] <= a[i-1]) {
    j -= 1
  };
  swap(a[i-1], a[j]);

  j = n - 1;
  while (i < j) {
    swap(a[i], a[j]);
    i += 1; j -= 1;
  }

  return true; // 다음 순열이 존재한다.
}

```

## 4. 재귀 함수 사용하기

## 5. 비트마스크

- bit 연산을 이용해서 부분 집합 표현이 가능하다. (`&`, `|`, `~`, `^`)
- `~` 연산은 자료형에 따라 결과가 달라짐 (8비트, 32비트 등... 앞쪽에 붙는 0 때문에)
- shift left (`<<`), shift right (`>>`)
  - 3 `<<` 3 = 24 (11000_2)
  - 1 << N === 2^N 을 의미

정수로 집합을 나타낼 때 사용
